#' Calculate a Net Promoter Score
#'
#' This function calculates a Net Promoter Score from a vector of
#' \emph{Recommend} scores, ideally \code{\link{numeric}} ones. An attempt will
#' be made to coerce \code{\link{factor}}, or \code{\link{character}} data.
#' \code{NA} values, either in the data, or generated by type coercion, are
#' automatically omitted from the calculation. No warning is given in the former
#' case. Net Promoter Scores generated are on a [-1,1] scale; you may want to
#' multiply them by 100 (and perhaps round them!) prior to presentation.
#'
#' @param x A vector of \emph{Recommend} scores
#' @param breaks A \code{list} of length three, giving the integer Likert scale
#'   points for \emph{Detractors}, \emph{Passives}, and \emph{Promoters},
#'   respectively. The default is \code{list(0:6, 7:8, 9:10)}
#' @return a Net Promoter Score. Unrounded.
#' @aliases nps
#' @export
#' @seealso \code{\link{npc}}
#' @author Brendan Rocks \email{rocks.brendan@@gmail.com}
#' @examples
#' # This will generate 1000 dummy Likelihood to Recommend reponses
#' x <- sample(
#'   0:10, 1000, replace = TRUE,
#'   prob = c(0.02, 0.01, 0.01, 0.01, 0.01, 0.03, 0.03, 0.09, 0.22, 0.22, 0.35)
#' )
#'
#' # Here are the proportions of respondents giving each Likelihood to
#' # Recommend response
#' prop.table(table(x))
#'
#' # Here's a histrogram of the scores
#' hist(
#'   x, breaks = -1:10,
#'   col = c(rep("red", 7), rep("yellow", 2), rep("green", 2))
#' )
#'
#' # Here's a barplot. It's very similar, though for categorical responses
#' # it's often slightly easier to interpret.
#' barplot(
#'  prop.table(table(x)),
#'  col = c(rep("red", 7), rep("yellow", 2), rep("green", 2))
#' )
#'
#' # Here's the NPS
#' nps(x)
#'
#' # You can round it if you like
#' round(nps(x)) ; round(nps(x), 1)
nps <- function(x, breaks = getOption("nps.breaks"), na.rm = FALSE){
  nps_format(mean(as.numeric(npc(x)) - 2, na.rm = na.rm))
}


nps_ <- function(x) {
  nps_format((x[3] - x[1]) / sum(x))
}


#' Create Net Promoter Categories from Likelihood to Recommend Scores
#'
#' This function produces Net Promoter Categories for \code{\link{numeric}} or
#' \code{\link{integer}} \emph{Recommend} data
#'
#' @name npc
#' @aliases npc
#' @inheritParams nps
#' @return Net Promoter categories
#' @export
#' @seealso \code{\link{nps}}
#' @author Brendan Rocks \email{rocks.brendan@@gmail.com}
#' @examples
#' # The command below will generate Net Promoter categories for each point
#' # on a standard 0:10 Likelihood to Recommend scale
#' npc(0:10)
#'
#'  # Here's how scores and categories map out. Notice that scores which are
#'  # 'off the scale' drop out as missing/invalid
#' data.frame(score = -2:12, category = npc(-2:12))
#'
#' # When you have lots of data, summaries are useful
#' x <- sample(
#'   0:10, 1000, replace = TRUE,
#'   prob = c(0.02, 0.01, 0.01, 0.01, 0.01, 0.03, 0.03, 0.09, 0.22, 0.22, 0.35)
#' )
#'
#' # A Histrogram of the Likelihood to Recommend scores we just generated
#' hist(x, breaks=-1:10)
#'
#' # A look at the by nps category using summary
#' summary(npc(x))
#'
#' # As above
#' table(npc(x))
#'
#' # As a crosstabulation
#' table(x, npc(x))
#'
#' nps(x)
npc <- function(x, breaks = getOption("nps.breaks")) {

  # Coerce to numeric
  if (!is.numeric(x)) {
    message("Warning: Data of class ", paste(class(x), collapse = " "),
            " supplied; converted to numeric.")
    x <- as.numeric(as.character(factor(x, levels = unlist(breaks))))
  }

  # Check if any of the supplied values are outside of the range of the breaks
  # provided

  cut(x, breaks, include.lowest = TRUE,
      labels = c("Detractor", "Passive", "Promoter"))
}


#' Calculate the variance of a Net Promoter Score
#'
#' This function calculates the Net Promoter Score variance, taking a
#' \code{\link{vector}} of length three, with numbers or proportions of
#' \emph{Detractors}, \emph{Passives}, and \emph{Promoters}, respectively.
#'
#' @param x A \code{\link{vector}} of length three, with numbers or proportions
#'   of \emph{Detractors}, \emph{Passives}, and \emph{Promoters}, respectively
#' @name npvar
#' @aliases npvar
#' @return \code{\link{numeric}}. The variance of the distribution, ranging from
#'   0 to 1.
#' @export
#' @seealso \code{\link{nps.var}}, a version which works on raw Recommend
#'   responses
#' @author Brendan Rocks \email{rocks.brendan@@gmail.com}
nps_var_ <- function(x, na.rm = FALSE) {
  props <- as.numeric(prop.table(x))
  nps_format((props[3] + props[1]) - (props[3] - props[1]) ^ 2)
}


#' Calculate the variance of a Net Promoter Score
#'
#' This function calculates the Net Promoter Score variance, taking a
#' \code{\link{vector}} of raw \emph{Recommend} data
#'
#' @name nps.var
#' @aliases nps.var
#' @inheritParams nps
#' @return \code{\link{numeric}}. The variance of the distribution, ranging from
#'   0 to 1.
#' @export
#' @seealso \code{\link{npvar}}, a version which works on counts or proportions
#'   of responses
#' @author Brendan Rocks \email{rocks.brendan@@gmail.com}
nps_var <- function(x, breaks = getOption("nps.breaks"), na.rm = FALSE) {
  # Break the raw scores into categories
  categories <- npc(x, breaks)

  # Throw an NA if you're supposed to
  if (any(is.na(categories)) & !na.rm) {
    return(NA)
  }

  # Calculate the variance from the aggregates
  nps_var_(table(categories))
}


#' Calculate the standard error of a Net Promoter Score
#'
#' This function calculates the standard error (see below) of a Net Promoter
#' Score, taking a \code{\link{vector}} of raw \emph{Recommend} data
#'
#' @name nps.se
#' @aliases nps.se
#' @inheritParams nps
#' @return \code{\link{numeric}}. The variance of the distribution, ranging from
#'   0 to 1.
#' @export
#' @seealso \code{\link{npvar}}, a version which works on counts or proportions
#'   of responses
#' @author Brendan Rocks \email{rocks.brendan@@gmail.com}
nps_se <- function(x, breaks = getOption("nps.breaks"), na.rm = FALSE) {
  nps_format(
    sqrt(nps_var(x, na.rm = na.rm) / sum(!is.na(npc(x))))
  )
}


nps.var <- function(...) {
  nps2_name_check()
  nps_var(...)
}

nps.se <- function(...) {
  nps2_name_check()
  nps_se(...)
}

#' Strips Likert scale point labels, returns numeric or ordinal data
#'
#' Survey systems export responses to Likhert scales with the scale labels on,
#' meaning that R as factors or text as opposed to numeric data. This function
#' takes labelled scales and returns unlabelled numeric data (by default), or an
#' unlabelled ordered factor (if requested).
#'
#' @name scalestrip
#' @aliases scalestrip
#' @param x a \code{\link{vector}}, \code{\link{matrix}}, or
#'   \code{\link{data.frame}}, containing Likert data labelled in the format
#'   "Integer - some text", e.g. "10 - Extremely Likely"
#' @param ordinal \code{\link{logical}} (\code{TRUE}\\code{FALSE}). Should the
#'   data returned be an ordered factor? Otherwise the data returned is
#'   \code{\link{numeric}}. Defaults to \code{FALSE}.
#' @return Unlabelled numeric data (by defualt), or an unlabelled ordered factor
#'   (if requested).
#' @export
#' @author Brendan Rocks \email{rocks.brendan@@gmail.com}
scalestrip <- function(x, ordinal = FALSE) {
  out <- function(x) switch(ordinal + 1, as.numeric(x), ordered(x))

  if (!(is.data.frame(x) | is.matrix(x))) {
    return(out(as.numeric(gsub("[[:alpha:]]|[[:punct:]]", "", x))))
  }

  else if (is.data.frame(x) | is.matrix(x)) {
    for (i in 1:ncol(x)) {
      x[, i] <- out(gsub("[[:alpha:]]|[[:punct:]]", "", x[, i]))
    }
    return(x)
  }
}

#' @return \code{NULL}
#'
#' @rdname nps_test
#' @export
print.nps_test <- function(x, ...) {
  cat(x$type, "Net Promoter Score Z test\n\n")

  cat("NPS of x: ", round(x$nps.x,2), " (n = " , x$n.x, ")\n", sep = "")

  if (x$type == "Two sample") {
    cat("NPS of y: ", round(x$nps.y,2), " (n = " , x$n.y, ")\n", sep = "")
    cat("Difference:", round(x$delta,2), "\n")
  }
  cat("\n")

  cat(
    if (x$type == "One sample") "Standard error of x:"
    else
      "Standard error of difference:"
    , round(x$se.hat, 3), "\n")

  cat("Confidence level:", x$conf, "\n")
  cat("p value:", x$p.value, "\n")
  cat("Confidence interval:", x$int, "\n\n")
}
